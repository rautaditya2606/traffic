<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Traffic Management System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --light-color: #ecf0f1;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --dark-color: #2c3e50;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f6fa;
            color: #2c3e50;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px 0;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        header h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .panel h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light-color);
        }
        
        /* Traffic Network Visualization */
        #traffic-network {
            height: 500px;
            background-color: #f8f9fa;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            border: 1px solid #ddd;
        }
        
        .intersection {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .intersection:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }
        
        .intersection.signal-red { background-color: var(--danger-color); }
        .intersection.signal-green { background-color: var(--success-color); }
        .intersection.signal-yellow { background-color: var(--warning-color); }
        
        .delete-intersection-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 101;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }
        
        .intersection:hover .delete-intersection-btn {
            opacity: 1;
            pointer-events: auto;
        }
        
        .delete-intersection-btn:hover {
            transform: scale(1.2);
            background-color: #c0392b;
        }
        
        .delete-intersection-btn:active {
            transform: scale(0.95);
        }
        
        .road {
            position: absolute;
            height: 4px;
            background-color: #7f8c8d;
            transform-origin: 0 50%;
            z-index: 1;
            cursor: pointer;
            transition: all 0.2s;
            overflow: visible;
        }
        
        .road.highlighted {
            background-color: #2980b9;
            height: 6px;
            box-shadow: 0 0 8px rgba(41, 128, 185, 0.7);
        }
        
        .route-vehicle {
            position: absolute;
            font-size: 22px;
            z-index: 20;
            transform: translate(-50%, -50%);
            pointer-events: none;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.25));
        }
        
        .vehicle {
            position: absolute;
            font-size: 16px;
            z-index: 5;
            transform: translate(-50%, -50%);
            transition: left 0.5s linear, top 0.5s linear;
            pointer-events: none;
        }
        
        .vehicle.low { color: #2ecc71; }
        .vehicle.medium { color: #f39c12; }
        .vehicle.high { color: #e74c3c; }
        
        .road:hover {
            background-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        .road-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .road::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--secondary-color);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
        }
        
        .road.traffic-low::after { 
            transform: scaleX(0.3); 
            background-color: var(--success-color);
        }
        
        .road.traffic-medium::after { 
            transform: scaleX(0.6); 
            background-color: var(--warning-color);
        }
        
        .road.traffic-high::after { 
            transform: scaleX(1); 
            background-color: var(--danger-color);
        }
        
        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid var(--secondary-color);
        }
        
        .control-group h3 {
            margin-bottom: 10px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group h3 i {
            color: var(--secondary-color);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn-block {
            display: block;
            width: 100%;
        }
        
        .btn-success {
            background-color: var(--success-color);
        }
        
        .btn-success:hover {
            background-color: #27ae60;
        }
        
        .btn-danger {
            background-color: var(--danger-color);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        /* Status Indicators */
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-active { background-color: var(--success-color); }
        .status-inactive { background-color: #95a5a6; }
        
        /* Route Info */
        #route-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid var(--secondary-color);
            display: none;
        }
        
        #route-info h3 {
            margin-bottom: 10px;
            color: var(--primary-color);
        }
        
        .route-segment {
            padding: 8px;
            margin-bottom: 8px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid var(--secondary-color);
            font-size: 14px;
        }
        
        .route-segment .segment-header {
            display: flex;
            justify-content: space-between;
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        .traffic-badge {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 500;
            color: white;
        }
        
        .traffic-low { background-color: var(--success-color); }
        .traffic-medium { background-color: var(--warning-color); }
        .traffic-high { background-color: var(--danger-color); }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            #traffic-network {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1><i class="fas fa-traffic-light"></i> City Traffic Management System</h1>
            <p style="text-align: center; opacity: 0.8;">Monitor and manage city traffic in real-time</p>
        </div>
    </header>
    
    <div class="container">
        <div class="dashboard">
            <div class="panel">
                <h2><i class="fas fa-project-diagram"></i> Traffic Network</h2>
                <div id="traffic-network">
                    <!-- Intersections and roads will be rendered here by JavaScript -->
                </div>
                
                <div id="route-info">
                    <h3><i class="fas fa-route"></i> Route Information</h3>
                    <div id="route-details"></div>
                </div>
            </div>
            
            <div class="panel">
                <h2><i class="fas fa-sliders-h"></i> Controls</h2>
                
                <div class="controls">
                    <div class="control-group">
                        <h3><i class="fas fa-map-marker-alt"></i> Find Route</h3>
                        <div class="form-group">
                            <label for="from-intersection">From:</label>
                            <select id="from-intersection" class="form-control">
                                <option value="">Select starting point</option>
                                <% intersections.forEach(intersection => { %>
                                    <option value="<%= intersection.id %>">
                                        <%= intersection.name %> (<%= intersection.id %>)
                                    </option>
                                <% }); %>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="to-intersection">To:</label>
                            <select id="to-intersection" class="form-control">
                                <option value="">Select destination</option>
                                <% intersections.forEach(intersection => { %>
                                    <option value="<%= intersection.id %>">
                                        <%= intersection.name %> (<%= intersection.id %>)
                                    </option>
                                <% }); %>
                            </select>
                        </div>
                        <button id="find-route" class="btn btn-block">
                            <i class="fas fa-route"></i> Find Best Route
                        </button>
                    </div>
                    
                    <div class="control-group">
                        <h3><i class="fas fa-plus-circle"></i> Add Intersection</h3>
                        <div class="form-group">
                            <label for="intersection-id">ID:</label>
                            <input type="text" id="intersection-id" class="form-control" placeholder="e.g., E">
                        </div>
                        <div class="form-group">
                            <label for="intersection-name">Name:</label>
                            <input type="text" id="intersection-name" class="form-control" placeholder="e.g., East District">
                        </div>
                        <button id="add-intersection" class="btn btn-success">
                            <i class="fas fa-plus"></i> Add Intersection
                        </button>
                    </div>
                    
                    <div class="control-group">
                        <h3><i class="fas fa-road"></i> Add Road</h3>
                        <div class="form-group">
                            <label for="road-from">From:</label>
                            <select id="road-from" class="form-control">
                                <option value="">Select starting intersection</option>
                                <% intersections.forEach(intersection => { %>
                                    <option value="<%= intersection.id %>">
                                        <%= intersection.name %> (<%= intersection.id %>)
                                    </option>
                                <% }); %>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="road-to">To:</label>
                            <select id="road-to" class="form-control">
                                <option value="">Select destination intersection</option>
                                <% intersections.forEach(intersection => { %>
                                    <option value="<%= intersection.id %>">
                                        <%= intersection.name %> (<%= intersection.id %>)
                                    </option>
                                <% }); %>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="road-distance">Distance (km):</label>
                            <input type="number" id="road-distance" class="form-control" min="0.1" step="0.1" value="1.0">
                        </div>
                        <button id="add-road" class="btn btn-success">
                            <i class="fas fa-plus"></i> Add Road
                        </button>
                    </div>
                    
                    <div class="control-group">
                        <h3><i class="fas fa-traffic-light"></i> Traffic Simulation</h3>
                        <p>Traffic updates every 5 seconds</p>
                        <div class="form-group">
                            <label>Traffic Density Legend:</label>
                            <div style="display: flex; gap: 10px; margin-top: 5px;">
                                <span class="traffic-badge traffic-low">Light</span>
                                <span class="traffic-badge traffic-medium">Moderate</span>
                                <span class="traffic-badge traffic-high">Heavy</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Signal Status:</label>
                            <div style="display: flex; gap: 15px; margin-top: 5px;">
                                <div>
                                    <span class="status-indicator" style="background-color: #2ecc71;"></span>
                                    <span>Green</span>
                                </div>
                                <div>
                                    <span class="status-indicator" style="background-color: #f39c12;"></span>
                                    <span>Yellow</span>
                                </div>
                                <div>
                                    <span class="status-indicator" style="background-color: #e74c3c;"></span>
                                    <span>Red</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Socket.IO connection
        const socket = io();
        
        // Global variables
        let networkData = {
            intersections: <%- JSON.stringify(intersections) %>,
            roads: <%- JSON.stringify(roads) %>
        };
        
        // Store road elements for vehicle positioning
        const roadElements = new Map();
        
        // Vehicle management - only for traffic density vehicles (now disabled)
        const vehicles = new Map();
        
        // Remove all traffic density vehicles
        function removeAllTrafficVehicles() {
            for (const [id, vehicle] of vehicles.entries()) {
                if (vehicle && vehicle.element && vehicle.element.parentNode) {
                    vehicle.element.remove();
                }
                vehicles.delete(id);
            }
        }
        
        // Create tooltip element
        const roadTooltip = document.createElement('div');
        roadTooltip.className = 'road-tooltip';
        document.getElementById('traffic-network').appendChild(roadTooltip);
            
        // Initialize the traffic network visualization
        function initNetwork() {
            const container = document.getElementById('traffic-network');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Remove all traffic density vehicles before clearing
            removeAllTrafficVehicles();
            
            // Clear existing elements
            container.innerHTML = '';
            
            // Re-add the tooltip after clearing
            container.appendChild(roadTooltip);
            
            // Re-add route vehicle if it exists (it will be recreated by animation if needed)
            if (routeVehicleEl && routeVehicleEl.parentNode !== container) {
                container.appendChild(routeVehicleEl);
            }
            
            // Create intersections
            networkData.intersections.forEach((intersection, index) => {
                // Distribute intersections in a circle for visualization
                const angle = (index / networkData.intersections.length) * Math.PI * 2;
                const radius = Math.min(width, height) * 0.4;
                const x = (width / 2) + Math.cos(angle) * radius;
                const y = (height / 2) + Math.sin(angle) * radius;
                
                const el = document.createElement('div');
                el.className = `intersection signal-${intersection.signalStatus.toLowerCase()}`;
                el.textContent = intersection.id;
                el.style.left = `${x - 15}px`;
                el.style.top = `${y - 15}px`;
                el.title = `${intersection.name} (${intersection.id})\nSignal: ${intersection.signalStatus}`;
                el.dataset.intersectionId = intersection.id;
                
                // Create delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-intersection-btn';
                deleteBtn.innerHTML = 'Ã—';
                deleteBtn.title = 'Delete intersection';
                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    if (confirm(`Are you sure you want to delete intersection "${intersection.name}" (${intersection.id})?\nThis will also delete all connecting roads.`)) {
                        await deleteIntersection(intersection.id);
                    }
                });
                
                el.appendChild(deleteBtn);
                container.appendChild(el);
                
                // Store position for road drawing
                intersection.x = x;
                intersection.y = y;
            });
            
            // Create roads
            networkData.roads.forEach(road => {
                const fromIntersection = networkData.intersections.find(i => i.id === road.from);
                const toIntersection = networkData.intersections.find(i => i.id === road.to);
                
                if (fromIntersection && toIntersection) {
                    const dx = toIntersection.x - fromIntersection.x;
                    const dy = toIntersection.y - fromIntersection.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    const roadEl = document.createElement('div');
                    roadEl.className = 'road';
                    roadEl.style.width = `${length}px`;
                    roadEl.style.left = `${fromIntersection.x}px`;
                    roadEl.style.top = `${fromIntersection.y}px`;
                    roadEl.style.transform = `rotate(${angle}deg)`;
                    
                    // Store road element in the map
                    roadElements.set(`${road.from}-${road.to}`, roadEl);
                    
                    // Add data attributes for tooltip
                    roadEl.dataset.distance = road.distance;
                    roadEl.dataset.from = road.from;
                    roadEl.dataset.to = road.to;
                    
                    // Add hover events for tooltip
                    roadEl.addEventListener('mousemove', (e) => {
                        const rect = roadEl.getBoundingClientRect();
                        const networkRect = container.getBoundingClientRect();
                        
                        // Calculate position for tooltip (middle of the road)
                        const midX = (rect.left + rect.right) / 2 - networkRect.left + container.scrollLeft;
                        const midY = (rect.top + rect.bottom) / 2 - networkRect.top + container.scrollTop;
                        
                        roadTooltip.textContent = `${road.distance} KM (${road.from} to ${road.to})`;
                        roadTooltip.style.left = `${midX}px`;
                        roadTooltip.style.top = `${midY - 10}px`;
                        roadTooltip.style.opacity = '1';
                    });
                    
                    roadEl.addEventListener('mouseenter', () => {
                        roadTooltip.style.opacity = '1';
                    });
                    
                    roadEl.addEventListener('mouseleave', () => {
                        roadTooltip.style.opacity = '0';
                    });
                    
                    // Set traffic class based on density
                    if (road.trafficDensity < 0.3) {
                        roadEl.classList.add('traffic-low');
                    } else if (road.trafficDensity < 0.7) {
                        roadEl.classList.add('traffic-medium');
                    } else {
                        roadEl.classList.add('traffic-high');
                    }
                    
                    // Add tooltip with road info
                    roadEl.title = `${road.from} to ${road.to}\n` +
                                 `Distance: ${road.distance} km\n` +
                                 `Traffic: ${(road.trafficDensity * 100).toFixed(0)}%`;
                    
                    container.insertBefore(roadEl, container.firstChild);
                }
            });
        }
        
        // Vehicle management functions (kept for reference but not used - traffic vehicles disabled)
        function createVehicle(roadId, position, density) {
            const vehicle = document.createElement('div');
            vehicle.className = 'vehicle';
            vehicle.textContent = 'ðŸš—';
            
            // Set initial class based on density
            updateVehicleDensity(vehicle, density);
            
            document.getElementById('traffic-network').appendChild(vehicle);
            vehicles.set(roadId, { element: vehicle, position, density });
            return vehicle;
        }
        
        function updateVehicleDensity(vehicle, density) {
            vehicle.className = 'vehicle ' + 
                (density > 0.7 ? 'high' : density > 0.4 ? 'medium' : 'low');
        }
        
        function updateVehiclePositions(roads) {
            roads.forEach(road => {
                const roadElement = roadElements.get(`${road.from}-${road.to}`) || 
                                  roadElements.get(`${road.to}-${road.from}`);
                
                if (roadElement) {
                    const fromNode = networkData.intersections.find(i => i.id === road.from);
                    const toNode = networkData.intersections.find(i => i.id === road.to);
                    
                    if (fromNode && toNode) {
                        const roadLength = Math.sqrt(
                            Math.pow(toNode.x - fromNode.x, 2) + 
                            Math.pow(toNode.y - fromNode.y, 2)
                        );
                        
                        // Calculate number of vehicles based on traffic density
                        const vehicleCount = Math.min(5, Math.ceil(road.trafficDensity * 5));
                        
                        // Update or create vehicles
                        for (let i = 0; i < vehicleCount; i++) {
                            const vehicleId = `${road.from}-${road.to}-${i}`;
                            const position = (Math.sin(Date.now() / 2000 + i) + 1) / 2; // Oscillating position
                            
                            if (!vehicles.has(vehicleId)) {
                                createVehicle(vehicleId, position, road.trafficDensity);
                            }
                            
                            const vehicle = vehicles.get(vehicleId);
                            vehicle.position = position;
                            vehicle.density = road.trafficDensity;
                            
                            // Update vehicle position
                            const x = fromNode.x + (toNode.x - fromNode.x) * position;
                            const y = fromNode.y + (toNode.y - fromNode.y) * position;
                            
                            // Add slight offset to prevent overlapping
                            const offsetX = (toNode.y - fromNode.y) / roadLength * 15 * (i % 2 ? 1 : -1);
                            const offsetY = (fromNode.x - toNode.x) / roadLength * 15 * (i % 2 ? 1 : -1);
                            
                            vehicle.element.style.left = `${x + offsetX}px`;
                            vehicle.element.style.top = `${y + offsetY}px`;
                            
                            // Update vehicle rotation based on road direction
                            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x) * 180 / Math.PI;
                            vehicle.element.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
                            
                            // Update vehicle density class if changed
                            updateVehicleDensity(vehicle.element, road.trafficDensity);
                        }
                    }
                }
            });
            
            // Remove excess vehicles
            const currentIds = new Set(roads.flatMap(road => {
                const vehicleCount = Math.min(5, Math.ceil(road.trafficDensity * 5));
                return Array.from({length: vehicleCount}, (_, i) => `${road.from}-${road.to}-${i}`);
            }));
            
            // Remove vehicles that are no longer needed
            for (const [id, vehicle] of vehicles.entries()) {
                if (!currentIds.has(id)) {
                    vehicle.element.remove();
                    vehicles.delete(id);
                }
            }
        }
        
        // Animation loop - DISABLED: Only route vehicle shows now
        // function animate() {
        //     if (networkData && networkData.roads) {
        //         updateVehiclePositions(networkData.roads);
        //     }
        //     requestAnimationFrame(animate);
        // }
        
        // Start the animation loop - DISABLED
        // animate();
        
        // Update network data from server
        function updateNetwork(data) {
            // Store the previous network data for comparison
            const previousData = { ...networkData };
            networkData = data;
            
            // Reinitialize the network visualization
            initNetwork();
            
            // Remove all traffic density vehicles - only route vehicle shows now
            removeAllTrafficVehicles();
            
            // DISABLED: No longer showing vehicles based on traffic density
            // if (networkData.roads && networkData.roads.length > 0) {
            //     updateVehiclePositions(networkData.roads);
            // }
            
            // if (!previousData.roads && networkData.roads) {
            //     updateVehiclePositions(networkData.roads);
            // }
        }
        
        // Find and display route
        async function findRoute() {
            const from = document.getElementById('from-intersection').value;
            const to = document.getElementById('to-intersection').value;
            
            if (!from || !to) {
                alert('Please select both starting point and destination');
                return;
            }
            
            try {
                const response = await fetch(`/api/route?from=${from}&to=${to}`);
                const route = await response.json();
                
                if (route.error) {
                    throw new Error(route.error);
                }
                
                // Display route information
                const routeInfo = document.getElementById('route-info');
                const routeDetails = document.getElementById('route-details');
                
                routeInfo.style.display = 'block';
                
                let html = `
                    <p><strong>From:</strong> ${route.from}<br>
                    <strong>To:</strong> ${route.to}<br>
                    <strong>Total Distance:</strong> ${route.totalDistance.toFixed(1)} km</p>
                    <p><strong>Route:</strong> ${route.path.join(' â†’ ')}</p>
                    <h4>Route Segments:</h4>
                `;
                
                route.segments.forEach(segment => {
                    const trafficClass = segment.trafficStatus.toLowerCase();
                    html += `
                        <div class="route-segment">
                            <div class="segment-header">
                                <span>${segment.from} â†’ ${segment.to}</span>
                                <span class="traffic-badge ${trafficClass}">
                                    ${segment.trafficStatus} Traffic
                                </span>
                            </div>
                            <div>
                                <strong>Distance:</strong> ${segment.distance} km â€¢ 
                                <strong>Signal:</strong> 
                                <span style="color: ${segment.signalStatus === 'green' ? '#2ecc71' : segment.signalStatus === 'yellow' ? '#f39c12' : '#e74c3c'}">
                                    ${segment.signalStatus}
                                </span>
                            </div>
                        </div>
                    `;
                });
                
                routeDetails.innerHTML = html;
                
                // Scroll to route info
                routeInfo.scrollIntoView({ behavior: 'smooth' });
                
                // Highlight the roads on the selected route
                // First, clear any previous highlights
                document.querySelectorAll('#traffic-network .road.highlighted').forEach(el => {
                    el.classList.remove('highlighted');
                });
                
                // Add highlight to each segment's road (either direction)
                route.segments.forEach(segment => {
                    const keyForward = `${segment.from}-${segment.to}`;
                    const keyBackward = `${segment.to}-${segment.from}`;
                    const el = roadElements.get(keyForward) || roadElements.get(keyBackward);
                    if (el) el.classList.add('highlighted');
                });
                
                // Start the route vehicle animation
                startRouteAnimation(route);
                
            } catch (error) {
                alert('Error finding route: ' + error.message);
                console.error('Route error:', error);
            }
        }

        // Route animation state
        let routeVehicleEl = null;
        let cancelRouteAnimation = null;

        function getIntersectionById(id) {
            return networkData.intersections.find(i => i.id === id);
        }

        function getRoadData(from, to) {
            return networkData.roads.find(r => (r.from === from && r.to === to) || (r.from === to && r.to === from));
        }

        function createOrGetRouteVehicle(container) {
            if (routeVehicleEl) {
                // Make sure it's visible and in the container
                routeVehicleEl.style.display = 'block';
                if (routeVehicleEl.parentNode !== container) {
                    container.appendChild(routeVehicleEl);
                }
                return routeVehicleEl;
            }
            const el = document.createElement('div');
            el.className = 'route-vehicle';
            el.textContent = 'ðŸš—';
            el.style.display = 'none'; // Hidden initially
            container.appendChild(el);
            routeVehicleEl = el;
            return el;
        }

        function setVehiclePosition(el, fromNode, toNode, t) {
            const x = fromNode.x + (toNode.x - fromNode.x) * t;
            const y = fromNode.y + (toNode.y - fromNode.y) * t;
            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x) * 180 / Math.PI;
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        }

        // Animate a single segment from -> to and resolve when done
        function animateSegment(el, fromId, toId, durationMs, signal) {
            const fromNode = getIntersectionById(fromId);
            const toNode = getIntersectionById(toId);
            if (!fromNode || !toNode) return Promise.resolve();
            
            return new Promise((resolve) => {
                const start = performance.now();
                let rafId;
                
                function frame(now) {
                    // cancellation support
                    if (signal?.aborted) {
                        cancelAnimationFrame(rafId);
                        return;
                    }
                    const elapsed = now - start;
                    const t = Math.max(0, Math.min(1, elapsed / durationMs));
                    // ease in-out for smoothness
                    const eased = 0.5 - 0.5 * Math.cos(Math.PI * t);
                    setVehiclePosition(el, fromNode, toNode, eased);
                    if (t < 1) {
                        rafId = requestAnimationFrame(frame);
                    } else {
                        resolve();
                    }
                }
                
                rafId = requestAnimationFrame(frame);
            });
        }

        async function startRouteAnimation(route) {
            const container = document.getElementById('traffic-network');
            const vehicle = createOrGetRouteVehicle(container);
            
            // Make sure vehicle is visible
            vehicle.style.display = 'block';
            
            // cancel previous animation if any
            if (cancelRouteAnimation) cancelRouteAnimation.abort();
            const controller = new AbortController();
            cancelRouteAnimation = controller;
            
            // If no segments, position at start and return
            if (!route.segments || route.segments.length === 0) {
                const startNode = getIntersectionById(route.from);
                if (startNode) setVehiclePosition(vehicle, startNode, startNode, 0);
                return;
            }
            
            // Place vehicle at the start of the first segment
            const firstFrom = route.segments[0].from;
            const firstTo = route.segments[0].to;
            const firstFromNode = getIntersectionById(firstFrom);
            const firstToNode = getIntersectionById(firstTo);
            if (firstFromNode && firstToNode) setVehiclePosition(vehicle, firstFromNode, firstToNode, 0);
            
            // Move across each segment
            for (const seg of route.segments) {
                if (controller.signal.aborted) break;
                const road = getRoadData(seg.from, seg.to);
                const trafficFactor = road ? (1 + (road.trafficDensity || 0) * 2) : 1;
                // Base 1200ms per km feels snappy; scale by traffic
                const durationMs = Math.max(400, (seg.distance || 1) * 1200 * trafficFactor);
                await animateSegment(vehicle, seg.from, seg.to, durationMs, controller.signal);
            }
        }
        
        // Add intersection
        async function addIntersection() {
            const id = document.getElementById('intersection-id').value.trim();
            const name = document.getElementById('intersection-name').value.trim();
            
            if (!id || !name) {
                alert('Please fill in all fields');
                return;
            }
            
            try {
                const response = await fetch('/api/intersection', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id, name })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    alert('Intersection added successfully');
                    document.getElementById('intersection-id').value = '';
                    document.getElementById('intersection-name').value = '';
                    
                    // Reload the page to update the UI
                    window.location.reload();
                } else {
                    throw new Error(result.error || 'Failed to add intersection');
                }
            } catch (error) {
                alert('Error adding intersection: ' + error.message);
                console.error('Add intersection error:', error);
            }
        }
        
        // Add road
        async function addRoad() {
            const from = document.getElementById('road-from').value;
            const to = document.getElementById('road-to').value;
            const distance = parseFloat(document.getElementById('road-distance').value);
            
            if (!from || !to || isNaN(distance) || distance <= 0) {
                alert('Please fill in all fields with valid values');
                return;
            }
            
            if (from === to) {
                alert('Cannot create a road from an intersection to itself');
                return;
            }
            
            try {
                const response = await fetch('/api/road', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ from, to, distance })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    alert('Road added successfully');
                    // Reload the page to update the UI
                    window.location.reload();
                } else {
                    throw new Error(result.error || 'Failed to add road');
                }
            } catch (error) {
                alert('Error adding road: ' + error.message);
                console.error('Add road error:', error);
            }
        }
        
        // Delete intersection
        async function deleteIntersection(id) {
            try {
                const response = await fetch(`/api/intersection/${id}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Reload the page to update the UI and dropdown menus
                    window.location.reload();
                } else {
                    throw new Error(result.error || 'Failed to delete intersection');
                }
            } catch (error) {
                alert('Error deleting intersection: ' + error.message);
                console.error('Delete intersection error:', error);
            }
        }
        
        // Initialize the network when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initNetwork();
            
            // DISABLED: No longer showing vehicles based on traffic density
            // Only route vehicle (from Dijkstra path) will be shown
            // if (networkData && networkData.roads) {
            //     updateVehiclePositions(networkData.roads);
            // }
            
            // Handle Enter key in input fields
            document.getElementById('intersection-id').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addIntersection();
            });
            
            document.getElementById('intersection-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addIntersection();
            });
            
            document.getElementById('road-distance').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addRoad();
            });
            
            // Bind Find Route button
            document.getElementById('find-route').addEventListener('click', findRoute);
            // Bind Add Intersection button
            document.getElementById('add-intersection').addEventListener('click', addIntersection);
            // Bind Add Road button
            document.getElementById('add-road').addEventListener('click', addRoad);
        });
        
        // Listen for network updates from the server
        socket.on('network-update', (data) => {
            updateNetwork(data);
        });
        
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(initNetwork, 200);
        });
    </script>
</body>
</html>
